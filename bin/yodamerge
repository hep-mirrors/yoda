#! /usr/bin/env python

"""\
%prog [-o outfile] <yodafile1> <yodafile2> ...

Merge analysis objects from multiple YODA files, combining the statistics of
objects whose names are found in multiple files. May be used either to merge
disjoint collections of data objects, or to combine multiple statistically
independent runs of the same data objects into one high-statistics run.

TODO:
 * Use the generic yoda.read() and yoda.write() functions to do I/O to any format.
"""

import yoda, optparse, operator, itertools

parser = optparse.OptionParser(usage=__doc__)
parser.add_option('-o', '--output', default='-', dest='OUTPUT_FILE')
opts, filenames = parser.parse_args()

## Put the incoming objects into a dict from each path to a list of histos
analysisobjects_in = {}
for filename in filenames:
    # TODO: also accept AIDA, ROOT, ... inputs?
    aos = yoda.readYODA(filename)
    for ao in aos:
        analysisobjects_in.setdefault(ao.path, []).append(ao)

analysisobjects_out = {}
for p, aos in analysisobjects_in.iteritems():
    # print p, len(aos)
    ## Check that types match, and just output the first one if they don't
    if not all(type(ao) == type(aos[0]) for ao in aos):
        print "Several types of analysis object found at path %s: cannot be merged"
        analysisobjects_out[p] = aos[0]
        continue
    ## Check whether normalizations match
    normto = None
    if hasattr(aos[0], "totalDbn"):
        ## In the absence of better info, we use the norm as a heuristic to change the merging behaviour.
        # TODO: But what about if they are normed but to slightly different xsec estimates? Yuck. Need manual override
        # print tuple(ao.totalDbn.sumW for ao in aos)
        if all(ao.totalDbn.sumW == aos[0].totalDbn.sumW for ao in aos):
            normto = aos[0].totalDbn.sumW
        if normto:
            assert all(ao.annotations.has_key("ScaledBy") for ao in aos)
    for ao in aos:
        ## Unscale first if normto != None
        if normto:
            ao.scaleW(1/float(ao.annotations("ScaledBy")))
        if not analysisobjects_out.has_key(p):
            analysisobjects_out[p] = ao
        elif hasattr(ao, "__iadd__"):
            analysisobjects_out[p] += ao
        else:
            print "Analysis object %s of type %s cannot be merged" % (p, str(type(ao)))
            break
    ## Renormalize after adding if normto != None
    if normto:
        analysisobjects_out[p].normalize(normto)

yoda.writeYODA(analysisobjects_out.values(), opts.OUTPUT_FILE)
