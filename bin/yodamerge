#! /usr/bin/env python

"""\
%prog [-o outfile] <yodafile1> <yodafile2> ...

Merge analysis objects from multiple YODA files, combining the statistics of
objects whose names are found in multiple files. May be used either to merge
disjoint collections of data objects, or to combine multiple statistically
independent runs of the same data objects into one high-statistics run.

TODO:
 * Use the generic yoda.read() and yoda.write() functions to do I/O to any format.
"""

import yoda, optparse, operator, itertools

parser = optparse.OptionParser(usage=__doc__)
parser.add_option('-o', '--output', default='-', dest='OUTPUT_FILE')
opts, filenames = parser.parse_args()

## Put the incoming objects into a dict from each path to a list of histos
analysisobjects_in = {}
for filename in filenames:
    # TODO: also accept AIDA, ROOT, ... inputs?
    aos = yoda.readYODA(filename)
    for ao in aos:
        analysisobjects_in.setdefault(ao.path, []).append(ao)

analysisobjects_out = {}
for p, aos in analysisobjects_in.iteritems():
    ## Check that types match
    print p, len(aos)
    print tuple(type(ao) for ao in aos)
    print all(type(ao) == type(aos[0]) for ao in aos)
    ## Check whether normalizations match
    normto = None
    if hasattr(aos[0], "totalDbn"):
        ## In the absence of better info, we use this as a heuristic to change the merging behaviour.
        ## But what about if they are normed but to slightly different xsec estimates? Yuck. Need manual override
        print tuple(ao.totalDbn.sumW for ao in aos)
        if all(ao.totalDbn.sumW == aos[0].totalDbn.sumW for ao in aos):
            normto = aos[0].totalDbn.sumW
    # TODO: do a special unscale, store, add, renorm treatment if normto != None
    for ao in aos:
        if not analysisobjects_out.has_key(p):
            analysisobjects_out[p] = ao
        elif hasattr(ao, "__iadd__"):
            analysisobjects_out[p] += ao
        else:
            print "Analysis object %s of type %s cannot be merged" % (p, str(type(ao)))

yoda.writeYODA(analysisobjects_out.values(), opts.OUTPUT_FILE)
