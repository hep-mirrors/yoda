#! /usr/bin/env python

"""\
Usage: %prog 1.dat [2.dat ...]

Make a plot from each of the given plot data files.
"""

################
## Command line args:

import os, optparse
op = optparse.OptionParser(usage=__doc__)
op.add_option("-f", "--format", dest="FORMAT", default="PDF",
              help="output format string consisting of desired output formats separated by commas [default=%default]")
op.add_option("--mpl", dest="ENGINE", action="store_const", const="MPL", default="MPL",
              help="use MathText text renderer")
op.add_option("--tex", dest="ENGINE", action="store_const", const="TEX", default="MPL",
              help="use TeX text renderer")
op.add_option("--pgf", dest="ENGINE", action="store_const", const="PGF", default="MPL",
              help="use LaTeX PGF plot renderer")
op.add_option("--debug", dest="DEBUG", action="store_true", default=False,
              help="run in debug mode with more verbosity and no parallelism")
op.add_option("--quiet", dest="QUIET", action="store_true", default=False,
              help="run in quiet mode with no status output to terminal")
opts, args = op.parse_args()

## Set the verbosity level in response to --debug and --quiet args
opts.VERBOSITY = 1
if opts.DEBUG:
    opts.VERBOSITY = 2
if opts.QUIET:
    opts.VERBOSITY = 0


#################
## Data handling:

import numpy as np
import yoda
import plotting


############
## Plotting:

import matplotlib as mpl
mpl.rcParams.update({
    "text.usetex" : (opts.ENGINE.upper() != "MPL"),
    "font.size"   : 17,
    "font.family" : "serif",
    # "font.serif"         : ["TeX Gyre Pagella", "Palatino", "Computer Modern Roman"] + mpl.rcParams["font.serif"],
    # "font.sans-serif"    : ["Computer Modern Sans serif", "Helvetica"]
    # "font.cursive"       : "Zapf Chancery",
    # "font.monospace"     : "Courier, Computer Modern Typewriter",
    # "text.latex.preamble": [r"\addfontfeature{Numbers=OldStyle}", r"\usepackage{amsmath,amssymb}"],
    # "pgf.rcfonts" : False,
    #"pgf.preamble": [r"\usepackage[osf]{mathpazo}", r"\usepackage{amsmath,amssymb}"],
    "pgf.preamble": [r"\usepackage{amsmath,amssymb}", r"\usepackage{mathspec}",
                     # r"\usepackage{fontspec}", #r"\defaultfontfeatures{Numbers=OldStyle}",
                     r"\setmainfont[Numbers=OldStyle]{TeX Gyre Pagella}",
                     r"\setmathsfont(Digits,Latin)[Numbers=OldStyle,Scale=MatchUppercase]{TeX Gyre Pagella}"],
    # r"\usepackage{lmodern}",
    # r"\usepackage{sfmath}", ",]
    # r"\usepackage{siunitx},"]
    })
if opts.ENGINE.upper() == "PGF":
    mpl.use("pgf")
from matplotlib import pyplot as plt
# TODO: allocate a nice palette for line color cycling... or some automatic system for that?

## Colour and line style lists
colormap = plt.cm.gist_ncar
COLORS = [colormap(i) for i in np.linspace(0.2, 0.8, len(args))]
STYLES = ["-", "--", ":", "-."]


def plot(plotargs):
    idatfile, datfile = plotargs
    numdatfiles = len(args)

    ## Plan for output in (potentially) several different formats
    outfiles = []
    basename = os.path.splitext(datfile)[0]
    formats = opts.FORMAT.upper().split(",")
    if "PDF" in formats:
        outfiles.append(basename+".pdf")
    if "PNG" in formats:
        outfiles.append(basename+".png")
    if "PGF" in formats:
        outfiles.append(basename+".pgf")

    ## Print status update to terminal
    if opts.VERBOSITY > 0:
        outstr = " ".join(outfiles)
        print "Plotting file {f} -> {o} ({i}/{n})".format(f=datfile, o=outstr, i=idatfile+1, n=numdatfiles)

    ## Read PLOT section manually
    # TODO: move out into plotting.py
    inplot = False
    plotkeys = {}
    import re
    re_begin = re.compile("#*\s*BEGIN\s+PLOT\s*(\w*)")
    re_comment = re.compile("#.*")
    re_attr = re.compile("(\w+)\s*=\s*(.*)")
    re_end = re.compile("#*\s*END\s+PLOT\s+\w*")
    with open(datfile) as f:
        for line in f:
            l = line.strip()
            if re_begin.match(l):
                inplot = True
            elif re_begin.match(l):
                inplot = False
            elif re_comment.match(l):
                continue
            elif inplot:
                m = re_attr.match(l)
                if m is None: continue
                plotkeys[m.group(1)] = m.group(2)
    #print plotkeys

    ## Load and sort data objects
    aos = yoda.read(datfile)
    hs = sorted([plotting.NumpyHist(ao) for ao in aos.values()], key=lambda h: h.path)
    # TODO: allow plotting order specification via PlotIndex (-1 = no plot)

    ## Get data ranges
    xmin = min(min(h.xmin) for h in hs)
    xmax = max(max(h.xmax) for h in hs)
    xdiff = xmax - xmin
    ymin = min(min(h.ymin) for h in hs)
    ymax = max(max(h.ymax) for h in hs)
    ydiff = ymax - ymin

    # TODO: Round up ymax to nearest round number within 10% of ydiff, to create a top tick label

    ## Get whole-plot info: axis log/lin measure, ranges and labels
    title = None
    xlabel = plotkeys.get("XLabel", "") #"$x$ 1234567890 $1234567890$"
    ylabel = plotkeys.get("YLabel", "")
    # TODO: Dynamic default based on data ranges?
    xmeasure = "log" if plotting.as_bool(plotkeys.get("LogX", False)) else "lin"
    ymeasure = "log" if plotting.as_bool(plotkeys.get("LogY", False)) else "lin"


    ## Identify reference histo by annotation
    href = None
    for h in hs:
        if plotting.as_bool(h.annotations.get("RatioRef", False)):
            if href is None:
                href = h
            else:
                print "Ratio reference set twice: using first value = {}".format(href.path)

    ## Ratio plot styling via the reference histo annotations
    if href:
        ratioylabel = href.annotations.get("RatioYLabel", "Ratio")
        ratioerrcolor = href.annotations.get("RatioErrColor", "yellow")


    ## Make figure and subplot grid layout
    fig = plt.figure(figsize=(8, 6))
    if title:
        fig.suptitle(title, x=0.0)
    if href:
        gs = mpl.gridspec.GridSpec(2, 1, height_ratios=[3,1], hspace=0)
    else:
        gs = mpl.gridspec.GridSpec(1, 1, hspace=0)

    ## Main plot
    # TODO: take log axes and preference for round numbers into account in setting default axis limits
    axmain = fig.add_subplot(gs[0])
    if not href:
        axmain.set_xlabel(xlabel, x=1, ha="right", labelpad=None)
    axmain.set_ylabel(ylabel, y=1, ha="right", labelpad=None)
    # axmain.xaxis.set_major_locator(mpl.ticker.NullLocator())
    plt.setp(axmain.get_xticklabels(), visible=False)
    # TODO: Main plot manual limits
    # TODO: Main plot manual ticks
    axmain.set_ylim([ymin-0.1*ydiff, ymax+0.1*ydiff])
    axmain.hold(True)

    ## Ratio plot
    axratio = None
    if href:
        axratio = fig.add_subplot(gs[1], sharex=axmain)
        axratio.set_xlabel(xlabel, x=1, ha="right", labelpad=None)
        axratio.set_ylabel(ratioylabel)
        # TODO: Ratio plot manual limits
        # TODO: Ratio plot manual ticks
        axratio.hold(True)
        # TODO: Would be nice to add a display space fixed padding rather than prop to xdiff
        axratio.set_xlim([xmin-0.001*xdiff, xmax+0.001*xdiff])
        # TODO: manual ratio limit specification and RatioSymmRange option
        #axratio.set_ylim(0.5, 1.5)

        # Draw fill_between ref error band (do this before looping over cmp lines)
        ref_ymax_ratios = href.ymax/href.y
        ref_ymin_ratios = href.ymin/href.y
        # TODO: Diag: (needs -> limit handling at ends)
        # axratio.fill_between(href.x, ref_ymin_ratios, ref_ymax_ratios,
        #                      edgecolor="none", facecolor=ratioerrcolor, interpolate=False)
        # Stepped:
        def dbl_array(arr):
            return sum(([x,x] for x in arr), [])
        axratio.fill_between(href.xedges_dbl, dbl_array(ref_ymin_ratios), dbl_array(ref_ymax_ratios),
                             edgecolor="none", facecolor=ratioerrcolor)
        # TODO: Smoothed: (needs -> limit handling at ends)

        # Ratio = 1 marker line:
        axratio.axhline(1.0, color="gray")
        # TODO: specify ratio display in log/lin, abs, or #sigma, and as x/r or (x-r)/r


    ## Dataset plotting
    for ih, h in enumerate(hs):
        #print ih, h.path

        label = h.annotations.get("Title", None)

        default_color = h.annotations.get("Color", COLORS[ih % len(COLORS)])
        marker = h.annotations.get("Marker", h.annotations.get("PolyMarker", None)) # <- make-plots translation
        marker = {"*":"o"}.get(marker, marker) # <- make-plots translation
        mcolor = h.annotations.get("LineColor", default_color)
        errbar = h.annotations.get("ErrorBars", None)
        ecolor = h.annotations.get("ErrorBarsColor", default_color)
        line = h.annotations.get("Line", None)
        lcolor = h.annotations.get("LineColor", default_color)
        lstyle = h.annotations.get("LineStyle", "-")
        lstyle = {"solid":"-", "dashed":"--", "dotdashed":"-.", "dashdotted":"-.", "dotted":":"}.get(lstyle, lstyle) # <- make-plots translation
        lwidth = 1.4
        msize = 7

        ## If no drawing is enabled, default to a step line
        if not any(h.annotations.get(a) for a in ("Marker", "Line", "ErrorBars")):
            line = "step"

        ## Plotting
        artists = None
        if errbar:
            artists = axmain.errorbar(h.x, h.y, xerr=h.exminus, yerr=h.eyminus, color=ecolor, linestyle="none", linewidth=lwidth, capthick=lwidth) # linestyle="-", marker="o",
        if line == "step":
            artists = axmain.step(np.append(h.xmin, h.xmax[-1]), np.append(h.y, h.y[-1]), where="post", color=lcolor, linestyle=lstyle, linewidth=lwidth)
        elif line == "diag":
            artists = axmain.plot(h.x, h.y, color=lcolor, linestyle=lstyle, linewidth=lwidth)
        elif line == "smooth":
            from scipy.interpolate import spline
            xnew = np.linspace(h.x.min(), h.x.max(), 3*len(h))
            ynew = spline(h.x, h.y, xnew)
            artists = axmain.plot(xnew, ynew, color=lcolor, linestyle=lstyle, linewidth=lwidth)
        if marker:
            artists = axmain.plot(h.x, h.y, marker=marker, markersize=msize, linestyle="none", color=mcolor, markeredgecolor=mcolor)

        ## Legend entry
        if label and artists:
            artists[0].set_label(label)

        ## Ratio plot
        if href and h is not href:
            # TODO: exclude and specify order via RatioIndex
            assert h.same_binning_as(href)
            # TODO: log ratio or #sigma deviation
            yratios = h.y/href.y
            ## Stepped plot
            axratio.step(href.xedges_sgl, np.append(yratios, yratios[-1]), where="post", color=lcolor, linestyle=lstyle, linewidth=lwidth)
            # TODO: Diag plot
            # axratio.plot(href["x"], yratios, color="r", linestyle="--")
            # TODO: Smoothed plot


    # TODO: legend (can exclude and specify order via LegendIndex, position via LegendPos)
    axmain.legend(loc="best", fontsize="x-small", frameon=False)


    ## Tweak layout now that everything is in place
    if axratio:
        axratio.yaxis.set_major_locator(mpl.ticker.MaxNLocator(4, prune="upper"))
    fig.tight_layout()


    ## Output in each requested format
    for of in outfiles:
        fig.savefig(of)


## Do the rendering using a multiprocessing pool (cleaner than threads)
if opts.DEBUG:
    for a in enumerate(args):
        plot(a)
else:
    import multiprocessing
    pool = multiprocessing.Pool()
    pool.map(plot, zip(xrange(len(args)), args))
