#! /usr/bin/env python

"""\
Usage: %prog 1.dat [2.dat ...]

Make a plot from each of the given plot data files.
"""

################
## Data reading:

import os, optparse
op = optparse.OptionParser(usage=__doc__)
op.add_option("-f", "--format", dest="FORMAT", default="PDF",
              help="output format string consisting of desired output formats separated by commas [default=%default]")
op.add_option("--mpl", dest="ENGINE", action="store_const", const="MPL", default="MPL",
              help="use MathText text renderer")
op.add_option("--tex", dest="ENGINE", action="store_const", const="TEX", default="MPL",
              help="use TeX text renderer")
op.add_option("--pgf", dest="ENGINE", action="store_const", const="PGF", default="MPL",
              help="use LaTeX PGF plot renderer")
opts, args = op.parse_args()


#################
## Data handling:

import numpy as np
import yoda

class NumpyHist(object):
    def __init__(self, ao):
        if not isinstance(ao, yoda.AnalysisObject):
            raise Exception("ao argument must be a YODA AnalysisObject")
        ## Get annotations
        self.path = ao.path
        self.annotations = {aname : ao.annotation(aname) for aname in ao.annotations}
        ## Get data points
        points = ao.points if type(ao) is yoda.Scatter2D else ao.mkScatter().points
        self.data = np.zeros(len(points), dtype={'names':['x', 'y', 'exminus', 'explus', 'eyminus', 'eyplus'],
                                                 'formats':['f4', 'f4', 'f4', 'f4', 'f4', 'f4']}).view(np.recarray)
        for i, p in enumerate(points):
            self.data.x[i] = p.x
            self.data.y[i] = p.y
            self.data.exminus[i] = p.xErrs[0]
            self.data.explus[i]  = p.xErrs[1]
            self.data.eyminus[i] = p.yErrs[0]
            self.data.eyplus[i]  = p.yErrs[1]


    def __len__(self):
        return len(self.x)


    @property
    def xedges_sgl(self):
        return np.append(self.xmin, self.xmax[-1])

    @property
    def xedges_dbl(self):
        edges = np.empty((2*len(self.x),), dtype=self.x.dtype)
        edges[0::2] = self.xmin
        edges[1::2] = self.xmax
        return edges


    @property
    def xmin(self):
        return self.x - self.exminus

    @property
    def xmax(self):
        return self.x + self.explus


    @property
    def ymin(self):
        return self.y - self.eyminus

    @property
    def ymax(self):
        return self.y + self.eyplus


    @property
    def x(self):
        return self.data.x

    @property
    def y(self):
        return self.data.y

    @property
    def exminus(self):
        return self.data.exminus

    @property
    def explus(self):
        return self.data.explus

    @property
    def eyminus(self):
        return self.data.eyminus

    @property
    def eyplus(self):
        return self.data.eyplus

    # def __getattr__(self, attr):
    #     "Fall back to the data array for attributes not defined on NumpyHist"
    #     return getattr(self.data, attr)


    def same_binning_as(self, other):
        return (hcmp.x == href.x).all() and \
               (hcmp.exminus == href.exminus).all() and \
               (hcmp.explus == href.explus).all()


############
## Plotting:

import matplotlib as mpl
mpl.rcParams.update({
    "text.usetex" : (opts.ENGINE.upper() != "MPL"),
    "font.size"   : 17,
    "font.family" : "serif",
    "font.serif"         : ["Palatino", "Computer Modern Roman"] + mpl.rcParams["font.serif"],
    #"font.sans-serif"    : ["Computer Modern Sans serif", "Helvetica"]
    #"font.cursive"       : "Zapf Chancery",
    #"font.monospace"     : "Courier, Computer Modern Typewriter",
    "pgf.rcfonts" : True,
    "pgf.preamble": [r"\usepackage[osf]{mathpazo}", r"\usepackage{amsmath,amssymb}"]
    # r"\usepackage{lmodern}",
    # r"\usepackage{sfmath}", ",]
    # r"\usepackage{siunitx},"]
    })
if opts.ENGINE.upper() == "PGF":
    mpl.use("pgf")
from matplotlib import pyplot as plt
# TODO: allocate a nice palette for line color cycling... or some automatic system for that?

## Colour and line style lists
colormap = plt.cm.gist_ncar
COLORS = [colormap(i) for i in np.linspace(0.2, 0.8, len(args))]
STYLES = ["-", "--", ":", "-."]


def plot(a):
    aos = yoda.read(a)
    hs = [NumpyHist(ao) for ao in aos.values()]
    xmin = min(min(h.xmin) for h in hs)
    xmax = max(max(h.xmax) for h in hs)
    xdiff = xmax - xmin
    ymin = min(min(h.ymin) for h in hs)
    ymax = max(max(h.ymax) for h in hs)
    ydiff = ymax - ymin

    # TODO: loading a PLOT section

    # TODO: identify reference histo (by annotation rather than path?) and default-style differently
    href = None

    # TODO: use annotation style info

    ## Make subplot grid layout
    # fig, (axmain, axratio) = plt.subplots(nrows=2, ncols=1, sharex=True, squeeze=True)
    fig = plt.figure(figsize=(8, 6))
    gs = mpl.gridspec.GridSpec(2, 1, height_ratios=[3,1], hspace=0)

    ## Main plot
    # TODO: take log axes and preference for round numbers into account in setting default axis limits
    axmain = fig.add_subplot(gs[0])
    axmain.set_ylabel("FOO $\in y$")
    # axmain.xaxis.set_major_locator(mpl.ticker.NullLocator())
    plt.setp(axmain.get_xticklabels(), visible=False)
    axmain.set_ylim([ymin-0.1*ydiff, ymax+0.1*ydiff])
    axmain.hold(True)

    ## Comparison lines
    for ih, h in enumerate(hs):
        # TODO: use itertools.cycle?
        default_color = h.annotations.get("Color", COLORS[ih % len(COLORS)])
        marker = h.annotations.get("Marker", None)
        marker = {"*":"o"}.get(marker, marker) # <- make-plots translation
        mcolor = h.annotations.get("LineColor", default_color)
        errbar = h.annotations.get("ErrorBars", None)
        ecolor = h.annotations.get("ErrorBarsColor", default_color)
        line = h.annotations.get("Line", None)
        lcolor = h.annotations.get("LineColor", default_color)
        lstyle = h.annotations.get("LineStyle", "-")
        lstyle = {"solid":"-", "dashed":"--", "dotdashed":"-.", "dashdotted":"-.", "dotted":":"}.get(lstyle, lstyle) # <- make-plots translation
        lwidth=1.3

        ## If no drawing is enabled, default to a step line
        if not any(h.annotations.get(a) for a in ("Marker", "Line", "ErrorBars")):
            line = "step"

        ## Plotting
        if errbar:
            axmain.errorbar(h.x, h.y, xerr=h.exminus, yerr=h.eyminus, color=ecolor, linestyle="none", linewidth=lwidth, capthick=lwidth) # linestyle="-", marker="o",
        if line == "step":
            axmain.step(np.append(h.xmin, h.xmax[-1]), np.append(h.y, h.y[-1]), where="post", color=lcolor, linestyle=lstyle, linewidth=lwidth)
        elif line == "diag":
            axmain.plot(h.x, h.y, color=lcolor, linestyle=lstyle, linewidth=lwidth)
        elif line == "smooth":
            from scipy.interpolate import spline
            xnew = np.linspace(h.x.min(), h.x.max(), 3*len(h))
            ynew = spline(h.x, h.y, xnew)
            axmain.plot(xnew, ynew, color=lcolor, linestyle=lstyle, linewidth=lwidth)
        if marker:
            axmain.plot(h.x, h.y, marker=marker, linestyle="none", color=mcolor)

    # ## Ratio plot
    #assert hcmp.same_binning_as(href)
    # axratio = fig.add_subplot(gs[1], sharex=axmain)
    # axratio.set_xlabel("BAR $\in x$")
    # axratio.set_ylabel("MC / Data")
    # axratio.hold(True)
    # # TODO: Would be nice to add a display space fixed padding rather than prop to xdiff
    # axratio.set_xlim([xmin-0.001*xdiff, xmax+0.001*xdiff])
    # # Draw fill_between ref error band
    # ref_ymax_ratios = href.ymax/href.y
    # ref_ymin_ratios = href.ymin/href.y
    # # Continuous:
    # # axratio.fill_between(href.x, ref_ymin_ratios, ref_ymax_ratios,
    # #                      edgecolor="none", facecolor='yellow', interpolate=False)
    # # Stepped:
    # def dbl_array(arr):
    #     return sum(([x,x] for x in arr), [])
    # axratio.fill_between(href.xedges_dbl, dbl_array(ref_ymin_ratios), dbl_array(ref_ymax_ratios),
    #                      edgecolor="none", facecolor='yellow', interpolate=False)
    # # Ratio = 1 marker line:
    # axratio.axhline(1.0, color="gray")
    # for ih, hcmp in enumerate(hs):
    #     # TODO: log ratio or #sigma deviation
    #     yratios = hcmp.y/href.y
    #     #axratio.plot(href["x"], yratios, color="r", linestyle="--")
    #     axratio.step(href.xedges_sgl, np.append(yratios, yratios[-1]), where="post", color=COLORS[ih], linewidth=1.3)
    #     #axratio.set_ylim(0.5, 1.5)
    # axratio.yaxis.set_major_locator(mpl.ticker.MaxNLocator(4, prune="upper"))

    ## Automatically tweak layout now that everything is in place
    fig.tight_layout()


    ## Output in (potentially) several different formats
    abase = os.path.splitext(a)[0]
    if "PDF" in opts.FORMAT.upper().split(","):
        fig.savefig(abase+".pdf")
    if "PNG" in opts.FORMAT.upper().split(","):
        fig.savefig(abase+".png")
    if "PGF" in opts.FORMAT.upper().split(","):
        fig.savefig(abase+".pgf")



for a in args:
    print "Plotting file", a
    plot(a)
