#! /usr/bin/env python

"""\
%prog - generate histogram comparison plots

USAGE:
 %prog [options] yodafile1[:'Option1=Value':'Option2=Value':...]
       [path/to/yodafile2 ...] [PLOT:PlotOption1=Value:...]
"""

import yoda, sys, os

def main():

    from optparse import OptionParser, OptionGroup
    parser = OptionParser(usage=__doc__)
    parser.add_option('-o', '--outdir', dest='OUTDIR',
                      default='.', help='write data files into this directory')
    # parser.add_option("--hier-out", action="store_true", dest="HIER_OUTPUT", default=False,
    #                   help="write output dat files into a directory hierarchy which matches the analysis paths")
    # parser.add_option('--plotinfodir', dest='PLOTINFODIRS', action='append',
    #                   default=['.'], help='directory which may contain plot header information (in addition '
    #                   'to standard Rivet search paths)')

    # stygroup = OptionGroup(parser, "Plot style")
    # stygroup.add_option("--refid", dest="REF_ID",
    #                     default="REF", help="ID of reference data set (file path for non-REF data)")
    # stygroup.add_option("--linear", action="store_true", dest="LINEAR",
    #                     default=False, help="plot with linear scale")
    # stygroup.add_option("--mc-errs", action="store_true", dest="MC_ERRS",
    #                     default=False, help="show vertical error bars on the MC lines")
    # stygroup.add_option("--no-title", action="store_true", dest="NOPLOTTITLE",
    #                     default=False, help="don't show the plot title on the plot "
    #                     "(useful when the plot description should only be given in a caption)")
    # stygroup.add_option("--style", dest="STYLE", default="default",
    #                     help="change plotting style: default|bw|talk")
    # stygroup.add_option("-c", "--config", dest="CONFIGFILES", action="append", default=None, #["~/.make-plots"],
    #                     help="additional plot config file(s). Settings will be included in the output configuration.")
    # parser.add_option_group(stygroup)

    # TODO: re-enable the pattern matching, and _maybe_ the variants on ref-only plotting if we don't have a plotting system via YODA soon
    #
    selgroup = OptionGroup(parser, "Selective plotting")
    # selgroup.add_option("--show-single", dest="SHOW_SINGLE", choices=("no", "ref", "mc", "all"),
    #                     default="mc", help="control if a plot file is made if there is only one dataset to be plotted "
    #                     "[default=%default]. If the value is 'no', single plots are always skipped, for 'ref' and 'mc', "
    #                     "the plot will be written only if the single plot is a reference plot or an MC "
    #                     "plot respectively, and 'all' will always create single plot files.\n The 'ref' and 'all' values "
    #                     "should be used with great care, as they will also write out plot files for all reference "
    #                     "histograms without MC traces: combined with the -R/--rivet-refs flag, this is a great way to "
    #                     "write out several thousand irrelevant reference data histograms!")
    # selgroup.add_option("--show-mc-only", "--all", action="store_true", dest="SHOW_IF_MC_ONLY",
    #                     default=False, help="make a plot file even if there is only one dataset to be plotted and "
    #                     "it is an MC one. Deprecated and will be removed: use --show-single instead, which overrides this.")
    # # selgroup.add_option("-l", "--histogram-list", dest="HISTOGRAMLIST",
    # #                     default=None, help="specify a file containing a list of histograms to plot, in the format "
    # #                     "/ANALYSIS_ID/histoname, one per line, e.g. '/DELPHI_1996_S3430090/d01-x01-y01'.")
    selgroup.add_option("-m", "--match", action="append",
                        help="Only write out histograms whose $path/$name string matches these regexes. The argument "
                        "may also be a text file.",
                        dest="PATHPATTERNS")
    selgroup.add_option("-M", "--unmatch", action="append",
                        help="Exclude histograms whose $path/$name string matches these regexes",
                        dest="PATHUNPATTERNS")
    parser.add_option_group(selgroup)


    ## Parse command line args into filenames and associated annotations
    opts, args = parser.parse_args()
    fnames, fname_anns = [], []
    for a in args:
        fname, anns = parse_arg(a)
        fnames.append(fname)
        fname_anns.append(anns)


    ## Initialise regex list variables
    import re
    if opts.PATHPATTERNS is None:
        opts.PATHPATTERNS = []
    # See if a pattern option is an observable file and append its contents to
    # the pattern list
    import os
    for m in opts.PATHPATTERNS:
        if os.path.exists(m):
            f=open(m, "r")
            opts.PATHPATTERNS.extend([line.strip() for line in f if not line.startswith("#")])
            f.close()
    opts.PATHPATTERNS = [re.compile(r) for r in opts.PATHPATTERNS]
    if opts.PATHUNPATTERNS is None:
        opts.PATHUNPATTERNS = []
    opts.PATHUNPATTERNS = [re.compile(r) for r in opts.PATHUNPATTERNS]


    ## Load data objects into a dict of list[AO]s, and apply annotations
    aolists = {}
    for i, (fname, anns) in enumerate(zip(fnames, fname_anns)):
        aos = [ ao.mkScatter() for ao in yoda.read(fname, asdict=False) ]
        for ao in aos:
            for k, v in anns.iteritems():
                ao.setAnnotation(k, v)
            # TODO: Allow Rivet to strip /REF prefixes in its use of this API
            if ao.path.startswith("/REF"):
                ao.path = ao.path[4:]
            # TODO: Use arg[0] or --refid for identifying the ref histo (if there is one)
            if i == 0:
                ao.setAnnotation("RatioRef", "yes")
            ## Label with the original filename
            ao.setAnnotation("Origin", fname)
            ## Add to plotting dict
            aolists.setdefault(ao.path, []).append(ao)
    # print aolists.keys()


    ## Apply path pattern match discarding from dict
    for path in aolists.keys():
        useThis = True
        if opts.PATHPATTERNS:
            useThis = False
            for regex in opts.PATHPATTERNS:
                if regex.search(path):
                    useThis = True
                    break
        if useThis and opts.PATHUNPATTERNS:
            for regex in opts.PATHUNPATTERNS:
                if regex.search(path):
                    useThis = False
                    break
        if not useThis:
            del aolists[path]


    # TODO: read and apply .plot files


    ## Loop over unique paths, plotting in order of command-line appearance
    # TODO: bind default color/style cycling to the filenames

    ## Now loop over all MC histograms and plot them
    for path, aos in aolists.iteritems():

        ## Find and move the reference plot
        has_ref = False
        for i, ao in enumerate(aos):
            if ao.annotation("RatioRef", False):
                aos.insert(0, aos.pop(i))
                has_ref = True
                break

        ## Plot object for the PLOT section in the .dat file
        plot = Plot()
        plot["Legend"] = has_ref
        plot["LogY"] = True # TODO: make dynamic?
        # for key, val in plotparser.getHeaders(h).iteritems():
        #     plot[key] = val
        # if opts.LINEAR:
        #     plot["LogY'] = "0"
        # if opts.NOPLOTTITLE:
        #     plot["Title'] = ""

        # if opts.STYLE == "talk":
        #     plot["PlotSize"] = "8,6"
        # elif opts.STYLE == "bw":
        #     if opts.RATIO:
        #         plot["RatioPlotErrorBandColor"] = "black!10"


        ## Style the reference histo
        # TODO: Make style and label more customisable
        if aos[0].annotation("RatioRef", False):
            aos[0].setAnnotation("ErrorBars", "1")
            aos[0].setAnnotation("PolyMarker", "o")
            # aos[0].setAnnotation("ConnectBins", "0") # TODO: add
            aos[0].setAnnotation("Title", "Data") # TODO:improve


        # ## Loop over the MC files to plot all instances of the histogram
        # styleidx = 0
        # for infile in filelist:
        #     if mchistos.has_key(infile) and mchistos[infile].has_key(h):
        #         ## Default linecolor, linestyle
        #         setStyle(mchistos[infile][h], styleidx)
        #         styleidx += 1
        #         if opts.MC_ERRS:
        #             mchistos[infile][h].setAnnotation('ErrorBars', '1')
        #         ## Plot defaults from .plot files
        #         for key, val in plotparser.getHistogramOptions(h).iteritems():
        #             mchistos[infile][h].setAnnotation(key, val)
        #         ## Command line plot options
        #         setOptions(mchistos[infile][h], plotoptions[infile])
        #         mchistos[infile][h].setAnnotation('Path', infile + h)
        #         anaobjects.append(mchistos[infile][h])
        #         drawonly.append(infile + h)
        #         if opts.RATIO and ratioreference is None:
        #             ratioreference = infile + h

        # if opts.RATIO and len(drawonly) > 1:
        #     plot['RatioPlot'] = '1'
        #     plot['RatioPlotReference'] = ratioreference


        ## Create the output. We can't use yoda.writeFLAT because PLOT and SPECIAL aren't AOs
        from cStringIO import StringIO
        sio = StringIO()
        yoda.writeFLAT(aos, sio)
        output = str(plot) + "\n\n" + sio.getvalue()
        ##
        outpath = ao.path.strip("/").replace("/", "_") + ".dat" # TODO: tidy up
        with open(outpath, "w") as of:
            of.write(output)







def parse_arg(arg):
    "Function to parse a command line arg and return the filename + dict of command-line annotations"
    argparts = arg.split(":")
    fname = argparts[0]
    anns = {}
    for ann in argparts[1:]:
        if "=" in ann:
            aname, aval = ann.split("=")
            anns[aname] = aval
        else:
            anns["Title"] = ann
    return fname, anns


class Plot(dict):
    "A tiny Plot object to help writing out the head in the .dat file"
    def __repr__(self):
        return "# BEGIN PLOT\n" + "\n".join("%s=%s" % (k,v) for k,v in self.iteritems()) + "\n# END PLOT\n\n"


def mkoutdir(outdir):
    "Function to make output directories"
    if not os.path.exists(outdir):
        try:
            os.makedirs(outdir)
        except:
            msg = "Can't make output directory '%s'" % outdir
            raise Exception(msg)
    if not os.access(outdir, os.W_OK):
        msg = "Can't write to output directory '%s'" % outdir
        raise Exception(msg)


def writeOutput(output, h):
    "Choose output file name and dir"
    hparts = h.strip("/").split("/")
    if opts.HIER_OUTPUT:
        ana = "_".join(hparts[:-1]) if len(hparts) > 1 else "ANALYSIS"
        outdir = os.path.join(opts.OUTDIR, ana)
        outfile = '%s.dat' % hparts[-1]
    else:
        outdir = opts.OUTDIR
        outfile = '%s.dat' % "_".join(hparts)
    mkoutdir(outdir)
    outfilepath = os.path.join(outdir, outfile)
    f = open(outfilepath, 'w')
    f.write(output)
    f.close()


if __name__ == '__main__':
    main()














# def parseArgs(args):
#     """Look at the argument list and split it at colons, in order to separate
#     the file names from the plotting options. Store the file names and
#     file specific plotting options."""
#     filelist = []
#     plotoptions = {}
#     for a in args:
#         asplit = a.split(':')
#         path = asplit[0]
#         filelist.append(path)
#         plotoptions[path] = []
#         has_title = False
#         for i in xrange(1, len(asplit)):
#             ## Add 'Title' if there is no = sign before math mode
#             if not '=' in asplit[i] or ('$' in asplit[i] and asplit[i].index('$') < asplit[i].index('=')):
#                 asplit[i] = 'Title=%s' % asplit[i]
#             if asplit[i].startswith('Title='):
#                 has_title = True
#             plotoptions[path].append(asplit[i])
#         if not has_title:
#             plotoptions[path].append('Title=%s' % sanitiseString(os.path.basename( os.path.splitext(path)[0] )) )
#     return filelist, plotoptions


def setStyle(ao, style):
    """Set default plot styles (color and line width) colors borrowed from Google Ngrams"""
    LINECOLORS = ['{[HTML]{EE3311}}',  # red (Google uses 'DC3912')
                  '{[HTML]{3366FF}}',  # blue
                  '{[HTML]{109618}}',  # green
                  '{[HTML]{FF9900}}',  # orange... weirdly this screws up if the F is lower-case!
                  '{[HTML]{990099}}']  # lilac
    LINESTYLES = ['solid',
                  'dashed',
                  'dashdotted',
                  'dotted']

    if opts.STYLE == 'talk':
        ao.setAnnotation('LineWidth', '1pt')
    if opts.STYLE == 'bw':
        LINECOLORS = ['black!90',
                      'black!50',
                      'black!30']

    c = style % len(LINECOLORS)
    s = style / len(LINECOLORS)

    ao.setAnnotation('LineStyle', '%s' % LINESTYLES[s])
    ao.setAnnotation('LineColor', '%s' % LINECOLORS[c])


def setOptions(ao, options):
    "Set arbitrary annotations"
    for opt in options:
        key, val = opt.split('=', 1)
        ao.setAnnotation(key, val)


#--------------------------------------------------------------------------------------------
